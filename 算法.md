##### 主要学
10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；  
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。  

##### 时间复杂度
    时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。  

T(n) = O(f(n))  
T(n)：表示代码执行的时间  
f(n)：每行代码执行次数总和  
O：表示代码的执行时间T(n)与f(n)表达式成正比  ；O(1)表示常量级的复杂度，不是只执行一次  

分析： 
1. O这种复杂度表示方法只是表示一种变化趋势，而并非精确值，我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，实际就是n趋于无穷大后的表达式的值。 
eg：T(n) = O(2n+2) ->  T(n) = O(n) ; T(n) = O(2n^2+2n+3) -> T(n) = O(n^2)  

看一段代码块  
```java
/**
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
*/
```
第二第三行代码可表示为 2^0 * 2^1 * 2^3 ...2^k = n  ---> 2^k = n --> 求k --> k=log2^n  --> T(n)=O(log2^n)   

2. 复杂度由两个(或者多个)数据的规模来决定  

再看一段
```java
/**
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
*/
```
从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。  
针对这种情况，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

##### 空间复杂度
    空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。  
看一段代码
```java
/**
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }
  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
*/
```
跟时间复杂度分析一样，我们可以看到，第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，
所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。
我们常见的空间复杂度就是O(1)、O(n)、O(n2 )；

##### 复杂度总结  
    复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，
    越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )
    此外，还有4个概念要了解：最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、
    平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）
##### 稳定性
    稳定排序：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变；
    非稳定排序：上述场景有变化；

##### 数组
    数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
    
    线性表（Linear List）：顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。
    其实除了数组，链表、队列、栈等也是线性表结构。而与它相对立的概念是非线性表，比如二叉树、堆、图等。
    之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
    
    第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。
    但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，
    就需要做大量的数据搬移工作。

    数组下标为何从0开始？
    1. 方便计算内存地址偏移量，减少不必要的计算；
    a[k]_address = base_address + k * type_size；
    2. 历史原因，模仿C语言；

    n维数据：可以当做是存储(n-1)维数组的单维数组，寻址：有aa[m][n]的多维数据，那么aa[i][j]的地址是 address = base_address + (i * n + j) * type_size
    
##### 冒泡排序（Bubble Sort）
