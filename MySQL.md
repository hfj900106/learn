### 官方文档
【https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html】

### mysql相关问题 WAL机制、crash safe如何实现、redo log作用 

WAL （Write-Ahead Logging） ，关键点是：先写日志在写磁盘

当有一条记录需要更新的时候：

InnoDB引擎就会先把记录写到 redo log 里面，并更新内存（db buffer），这个时候更新就算完成了。

此时，内存（db buffer）中的数据和磁盘数据（data file）对应的数据不同，我们认为内存中的数据是脏数据（即：脏页）；

同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面（data file），而这个更新往往是在系统比较空闲的时候做。

### MySQL 中 update 修改数据与原数据相同会再次执行吗？
1. 在binlog_format=row和binlog_row_image=FULL时，由于MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来，那么重复数据的update不会执行。即MySQL 调用了 InnoDB 引擎提供的“修改为 (1,55)”这个接口，但是引擎发现值与原来相同，不更新，直接返回。
2. 在binlog_format = statement 和 binlog_row_image = FULL 时，InnoDB 内部认真执行了 update 语句，即“把这个值修改成 (1,999)“这个操作，该加锁的加锁，该更新的更新。

### 讲MySQL是怎么保证数据不丢的
1. 只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。（未完成）

### 表中有一列不定长，但是比较长的，且无规律的列，应该如何建索引高效查询
1. 考虑列是无规律，所以不能建前缀索引；位数较长，所以全量索引也不合适，浪费空间；
2. 表中加入一列用于存储CRC32（列）的值，用int(10)就够了，对这列加普通索引；
3. 举例：
```
如果需要存储大量的url，并需要根据url进行搜索查找。如果使用B-Tree来存储URL，存储的内容就会很大，因为URL本身都很长。正常情况下会有如下查询：
 
mysql> select id from url where url='http://www.mysql.com';
 
若删除原来url列上的索引，而新增一个被索引的url_crc列，使用crc32做哈希。就可以实现一个伪哈希索引；查询就变成下面的方式：
 
mysql> select id from url where url='http://www.mysql.com' and url_crc=crc32("http://www.mysql.com");
 

这样性能会提高很多。
当然这样实现的缺陷是需要维护哈希值，就是url改变对应哈希值也应该改变。可以手动维护，当然最好是使用触发器实现。

如果采用这种方式，不要使用SHA1()和MD5()作为哈希函数，应该这个函数计算出来的哈希值是非常长的字符串，会浪费大量空间，比较时也会更慢。
 
而如果数据表非常大，crc32()会出现大量的哈希冲突，而解决哈希冲突，可以在查询中增加url本身，进行进一步排除；
 
如下面查询就可以解决哈希冲突的问题：
mysql> select id from url where url='http://www.mysql.com' and url_crc=crc32("http://www.mysql.com");

```

### null和''空值
1. 在进行count()统计某列的记录数的时候，如果采用的NULL值，会别系统自动忽略掉，但是空值是会进行统计到其中的。 
2. 判断NULL 用IS NULL 或者 is not null,SQL 语句函数中可以使用ifnull()函数来进行处理，判断空字符用 =”或者 <>”来进行处理 
3. 对于MySQL特殊的注意事项，对于timestamp数据类型，如果往这个数据类型插入的列插入NULL值，则出现的值是当前系统时间。插入空值，则会出现 ‘0000-00-00 00:00:00’ 
4. 对于空值的判断到底是使用is null 还是 =”要根据实际业务来进行区分。
5. 空值（''）是不占用空间的，NULL其实是占用空间的（null列需要行中的额外空间来记录其值是否为null，对于myisam表，每一个空列都额外增加一位，四舍五入到最接近的字节）

### order by 排序
在排序时候，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer；
###### 全字段排序
1. 初始化sort_buffer，放入排序涉及到的字段（查询的字段，用于排序的字段）；
2. 对sort_buffer中的数据按照order字段做快速排序；
3. 结果返回客户端
```
番外：
排序可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size；sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序,number_of_tmp_files表示排序过程中使用的临时文件数,MySQL将需要排序的数据分成多份，每一份单独排序后存在这些临时文件中。然后把这有序文件再合并成一个有序的大文件。排序过程种的紧凑处理指的是按实际长度分配空间
```
###### rowid排序
全字段排序时如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。所以，如果MySQL认为排序的单行长度太大会怎么做呢？

max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。

过程：
1. 初始化sort_buffer，放入order字段和主键id；
2. 对sort_buffer中的数据按照order字段进行排序；
3. 遍历结果集，根据id回表，取出需要查询的字段集返回给客户端；

###### 总结
如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。

这也就体现了MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。排序需要生成临时表，若数据有序，则无需排序。

### 加锁规则（两个原则、两个优化、一个bug）

1. 原则1：加锁的基本单位是 next-key lock，前开后闭（等价 间隙锁+行锁）；
2. 原则2：扫描到的数据都会加锁；
3. 优化1：索引上等值查询，对 唯一索引 加锁，next-key lock 会变成 行锁；
4. 优化2：索引上等值查询，从第一个满足等值条件的索引记录开始向右遍历到第一个不满足等值条件记录，并将第一个不满足等值条件记录上的next-key lock 退化为间隙锁；
5. bug：唯一索引上的 范围查询 也会访问到 不满足条件 的 第一个 值为止。

番外：
1. 明确加了limit 的限制时，遍历满足条件的语句循环就结束了，不会往下查找，减少了锁的范围。
2. 增序 从小往大扫
3. 降序 从大往小扫，范围查询时，索引值是 >= 的时候最小值前面 会有两个间隙锁，如果没有 = ，那么只有一个间隙锁；

#### RC和RR隔离级别下的锁
1. RC + 读锁（行锁） ：其他事务中，可以新增索引值和锁住索引值一样的行数据，但是不可以根据被锁的索引值进行行数据的修改和删除；
2. RC + 写锁（行锁） ：其他事务中，只可以查；

3. RR + 读/写锁（行锁） ：唯一索引 + 等值查询；
4. RR + 读/写锁（行锁+间隙锁）：非唯一索引 + 等值/范围查询；唯一索引 + 范围查询； 

5. RC 的行锁冲突：读锁时， 可新增 不可修改、删除；写锁时，只可以查询；
6. RR 的行锁冲突：读锁时， 可读 不可修改、删除；写锁时，不可查询、修改、删除；

### RR隔离级别下 MySQL如何解决幻读
番外：
```
1. 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现;
2. 幻读仅专指[新插入的行] eg:session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。;
```
1. 快照读：MVCC
2. 当前读：间隙锁
但是间隙锁的引入会导致锁的范围变大，影响并发，也可能会导致死锁，具体才用哪种隔离级别需考虑具体的业务


### 一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？
1. 表引擎是MyISAM的话是18，因为MyISAM表会把自增主键id最大值记录到数据文件，重启或者optimize都不会导致最大值记录丢失；
2. 表引擎是InnoDB，在5.7版本的话是15，因为InnoDB会把自增主键id的最大值记录在内存，重启或者optimize都会导致最大值记录丢失；
    8.0版本的话是18，因为这个版本将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值

### 引起表锁的情况
1. 用到了低效的普通索引（重复率超高）
2. 没有用到索引


### 身份证为什么不适合做主键
1. 字段过长，且是字符类型，索引树占内存大；
2. 没有增长的趋势，插入数据可能引起数据页分裂和树节点位移；
分析:
如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都很可能插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面

番外：装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）

### 为什么MySQL使用B+而不是使用B树、二叉树、AVL树呢？
一步一步从二叉树——>AVL(平衡二叉树)——>B Tree（多路平衡查找树）——>B+ Tree的一个演变的过程来进行分析，为什么使用B+ Tree 的？
1. 




### 分库分表中间件
###### mycat（proxy层方案）
mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。

###### sharding-jdbc(当当开源的，属于 client 层方案)
sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合 sharding-jdbc 的依赖；
###### 比较
通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 mycat，然后大量项目直接透明使用即可

### 分库分表策略

###### 水平
1. 按数据量分（ID 取模 分库，查询也是取模规则查询），避免热点数据；
2. 按范围分（比如时间段），容易造成热点数据，分库后并没有给数据库流量减压

###### 垂直
把一个表按冷热字段分成两个或两个以上的表，一般在数据库设计的时候就尽量做好了，真实遇到的一般是水平分表


### 现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态迁移到分库分表上？
双写迁移方案（不停机动态迁移），一般分为四个步骤：
1. 选定一个分库分表中间件（mycat）；
2. 修改代码，新的数据写入旧库和中间件，中间件再将数据分到分库分表中；
3. 开发一个后台数据迁移的临时工具，将旧库的数据读出来给中间件，临时工具的逻辑中包括数据去重（比较最后修改时间，要是分库分表中不存在直接写入，要是存在比较时间戳，旧数据不能覆盖新数据，只能是新数据覆盖旧数据）；
4. 迁移完了比较新旧数据库中数据是否完整，不完整则继续重复导数据，直至数据一致（旧数据一致，新数据没有被覆盖）；
5. 修改代码将双写修改调，只写新的分库分表，重新发布；
 
 
### 以数据库为基本单位动态扩容
扩容无非是扩存储量、扩并发量
一般性能的数据库服务器单机2000/s，我们可以通过2倍法添加服务器，达到并发增强的效果，假设我们开始部署数据库的时候有M台服务器，那么我们可以在每台服务器上部署N个数据库，那么我们可以最大扩展到M * N 个服务器，这样每台服务器只有一个数据库，这样的基于数据库的扩容更为简单便捷；
路由：ID取模寻址
