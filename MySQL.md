

### mysql相关问题 WAL机制、crash safe如何实现、redo log作用 

WAL （Write-Ahead Logging） ，关键点是：先写日志在写磁盘

当有一条记录需要更新的时候：

InnoDB引擎就会先把记录写到 redo log 里面，并更新内存（db buffer），这个时候更新就算完成了。

此时，内存（db buffer）中的数据和磁盘数据（data file）对应的数据不同，我们认为内存中的数据是脏数据（即：脏页）；

同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面（data file），而这个更新往往是在系统比较空闲的时候做。

### 加锁规则（两个原则、两个优化、一个bug）

1. 原则1：加锁的基本单位是 next-key lock，前开后闭（等价 间隙锁+行锁）；
2. 原则2：扫描到的数据都会加锁；
3. 优化1：索引上等值查询，对 唯一索引 加锁，next-key lock 会变成 行锁；
4. 优化2：索引上等值查询，从第一个满足等值条件的索引记录开始向右遍历到第一个不满足等值条件记录，并将第一个不满足等值条件记录上的next-key lock 退化为间隙锁；
5. bug：唯一索引上的 范围查询 也会访问到 不满足条件 的 第一个 值为止。

番外：
1. 明确加了limit 的限制时，遍历满足条件的语句循环就结束了，不会往下查找，减少了锁的范围。
2. 增序 从小往大扫，降序 从大往小扫，注意间隙锁；

### MySQL 中 update 修改数据与原数据相同会再次执行吗？
1. 在binlog_format=row和binlog_row_image=FULL时，由于MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来，那么重复数据的update不会执行。即MySQL 调用了 InnoDB 引擎提供的“修改为 (1,55)”这个接口，但是引擎发现值与原来相同，不更新，直接返回。
2. 在binlog_format = statement 和 binlog_row_image = FULL 时，InnoDB 内部认真执行了 update 语句，即“把这个值修改成 (1,999)“这个操作，该加锁的加锁，该更新的更新。

### 讲MySQL是怎么保证数据不丢的
1. 只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。（未完成）

### 表中有一列不定长，但是比较长的，且无规律的列，应该如何建索引高效查询
1. 考虑列是无规律，所以不能建前缀索引；位数较长，所以全量索引也不合适，浪费空间；
2. 表中加入一列用于存储CRC32（列）的值，用int(10)就够了，对这列加普通索引；
3. 举例：
```
如果需要存储大量的url，并需要根据url进行搜索查找。如果使用B-Tree来存储URL，存储的内容就会很大，因为URL本身都很长。正常情况下会有如下查询：
 
mysql> select id from url where url='http://www.mysql.com';
 
若删除原来url列上的索引，而新增一个被索引的url_crc列，使用crc32做哈希。就可以实现一个伪哈希索引；查询就变成下面的方式：
 
mysql> select id from url where url='http://www.mysql.com' and url_crc=crc32("http://www.mysql.com");
 

这样性能会提高很多。
当然这样实现的缺陷是需要维护哈希值，就是url改变对应哈希值也应该改变。可以手动维护，当然最好是使用触发器实现。

如果采用这种方式，不要使用SHA1()和MD5()作为哈希函数，应该这个函数计算出来的哈希值是非常长的字符串，会浪费大量空间，比较时也会更慢。
 
而如果数据表非常大，crc32()会出现大量的哈希冲突，而解决哈希冲突，可以在查询中增加url本身，进行进一步排除；
 
如下面查询就可以解决哈希冲突的问题：
mysql> select id from url where url='http://www.mysql.com' and url_crc=crc32("http://www.mysql.com");

```

### null和''空值
1. 在进行count()统计某列的记录数的时候，如果采用的NULL值，会别系统自动忽略掉，但是空值是会进行统计到其中的。 
2. 判断NULL 用IS NULL 或者 is not null,SQL 语句函数中可以使用ifnull()函数来进行处理，判断空字符用 =”或者 <>”来进行处理 
3. 对于MySQL特殊的注意事项，对于timestamp数据类型，如果往这个数据类型插入的列插入NULL值，则出现的值是当前系统时间。插入空值，则会出现 ‘0000-00-00 00:00:00’ 
4. 对于空值的判断到底是使用is null 还是 =”要根据实际业务来进行区分。
5. 空值（''）是不占用空间的，NULL其实是占用空间的（null列需要行中的额外空间来记录其值是否为null，对于myisam表，每一个空列都额外增加一位，四舍五入到最接近的字节）

### order by 排序
在排序时候，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer；
###### 全字段排序
1. 初始化sort_buffer，放入排序涉及到的字段（查询的字段，用于排序的字段）；
2. 对sort_buffer中的数据按照order字段做快速排序；
3. 结果返回客户端
```
番外：
排序可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size；sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序,number_of_tmp_files表示排序过程中使用的临时文件数,MySQL将需要排序的数据分成多份，每一份单独排序后存在这些临时文件中。然后把这有序文件再合并成一个有序的大文件。排序过程种的紧凑处理指的是按实际长度分配空间
```
####### rowid排序
全字段排序时如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。所以，如果MySQL认为排序的单行长度太大会怎么做呢？

max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。

过程：
1. 初始化sort_buffer，放入order字段和主键id；
2. 对sort_buffer中的数据按照order字段进行排序；
3. 遍历结果集，根据id回表，取出需要查询的字段集返回给客户端；

####### 总结
如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。

这也就体现了MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。排序需要生成临时表，若数据有序，则无需排序。





