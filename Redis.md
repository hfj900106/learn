
# redis 连环问

### 我看你们项目中用了Redis，你们项目中怎么用的，用来解决什么问题？
高性能：存储一些不常修改但是查询量比较大的数据。
### 为什么Redis是单线程
Redis单线程模型中最核心的（文件事件处理器）file event handler 是单线程的，决定了Redis是单线程；
单线程模型：
1. 客户端socket01 -》 Redis服务器端server socket（产生事件：AE_READBLE）-》IO多路复用程序（监听请求并将数据压入队列，以下同理）-》socket队列-》文件事件分派器-》1.链接应答处理器-》1.在服务器上创建一个socket01和客户端保持链接，并将socket01的AE_READBLE事件与命令请求处理器关联；
2. 客户端socket01 -》 Redis服务器端 socket01（产生事件：AE_READBLE）-》IO多路复用程序-》socket队列-》文件事件分派器-》2.命令请求处理器-》2.从socket冲取出key，value存入内存，并将socket01的AE_WRITEBLE事件与命令回复处理器关联；
3. 客户端socket01 -》 Redis服务器端socket01（产生事件：AE_WRITEBLE）-》IO多路复用程序-》socket队列-》文件事件分派器-》3.命令回复处理器-》对socket01输出OK，将socket01的AE_WRITEBLE事件与命令回复处理器 解除 关联；

### 为什么支持高并发？（单机一秒钟可以处理几万个请求）
1. 基于内存，文件事件处理器处理效率高；
2. 非阻塞I/O多路复用；
3. 单线程，避免上下文切换问题；



### 缓存雪崩
名词解析：缓存服务宕机或者大部分key同一时间失效，导致大量的查询都落到数据库导致崩溃。

解决办法：
1. 针对同时失效场景：加锁排队，只能有一个线程去构建缓存，设置合理的过期时间，其他线程再从缓存拿数据；
2. 针对宕机场景：
    事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃；
    事中：本地 ehcache 缓存 + hystrix 限流 & 降级，避免 MySQL 被打死；
    事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据；
    
### 缓存穿透
名词解释：查询一个不存在的数据，那么缓存中是没有的，只能到数据库查，直接穿过缓存，要是被利用攻击，后果可想而已

解决办法：
1. bloom filter：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。guava中有实现BloomFilter算法。
2. 空值缓存：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。


### 缓存击穿
名词解释：热点数据刚好缓存失效，那么高并发的查询直接打到数据库

解决办法：
1. 将热点数据设置为永远不过期；
2. 加锁排队，只能有一个线程去构建缓存，设置合理的过期时间，其他线程再从缓存拿数据；

### redis持久化方式？优缺点？实现？

###### 方式（默认RDB）
1. RDB（Redis datebase）
是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。

自动触发：
　　在 redis.conf 配置文件中的 SNAPSHOTTING 下：
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存；
不需要持久化则save "" 或者 直接注释掉所有save；

手动触发：
save：会阻塞；bgsave:后台异步；
基本上都是bgsave

数据恢复：
将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。

优势：
1.1 主线程会fork()一个线程进行存盘工作，主线程不需要IO，可以高效提供服务；
1.2 保存的是数据集，恢复速度快，适用备份和灾难恢复；

劣势：
2.1 宕机会丢失最后时刻未进行存盘的数据；
2.2 bgsave每次会fork子线程，没法做到实时持久化，频繁执行成本高，影响性能；

https://www.cnblogs.com/ysocean/p/9114268.html

2. AOF（append-only-file）

https://www.cnblogs.com/ysocean/p/9114267.html
对于数据完整性要求较高的可以用

对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。

触发配置：
在 redis.conf 配置文件的 APPEND ONLY MODE 下：
appendonly：默认值为no，也就是说redis 默认使用的是rdb方式持久化，如果想要开启 AOF 持久化方式，需要将 appendonly 修改为 yes。

数据恢复：同RDB，异常修复命令：redis-check-aof --fix

AOF重写：
为解决aof文件越写越大，占内存且恢复速度慢，Redis增加了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重写。子线程直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。
触发条件在redis.conf 配置文件配置；

因为子进程在进行 AOF 重写期间，服务器进程依然在处理其它命令，这新的命令有可能也对数据库进行了修改操作，使得当前数据库状态和重写后的 AOF 文件状态不一致。为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。

优点：
1. 默认每秒同步一次，就是丢失也只是一秒的数据，
2. AOF 文件的格式可读性较强，不小心错用了 FLUSHALL 命令，在重写还没进行时，将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。

缺点：
1. 相同数量的Redis，AOF文件的体积比RDB大；
2. 负载较高的情况下每秒一次的频率比较吃力，耗性能；
3. 存在一些RDB没有的bug，数据恢复速度不如RDB快；

###### 如何选择两种方式

数据完整性要求不是特别严格的场景可以选RDB；
推荐平时使用两种方式并存，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。Redis后期官方可能都有将两种持久化方式整合为一种持久化模型。

### 如何保证缓存数据库双写一致

先更新数据库，再删除缓存；

但是这种情况在缓存刚好失效且有并发的情况可能回造成脏数据：
1. 缓存失效
2. B线程先更新数据库（还未提交）；
3. A线程查询到旧数据，想要放到缓存（还没有放）；
4. B提交并去删除缓存（虽然此时缓存没有，但还是操作）；
5. A将数据放入缓存
这过程本来是应该缓存B的值，结果是旧数据，不过这种几率很小，因为写肯定会比读快很多，这样缓存会被B删掉，下次查询会得到新的数据；
如何解决上述并发问题？
首先，给缓存设有效时间是一种方案。其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。

还有一个问题？要是缓存删除不成功怎么办？
（1）更新数据库数据
（2）数据库会将操作信息写入binlog日志当中
（3）订阅程序提取出所需要的数据以及key
（4）另起一段非业务代码，获得该信息
（5）尝试删除缓存操作，发现删除失败
（6）将这些信息发送至消息队列
（7）重新从消息队列中获得该数据，重试操作。
备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。

### Redis内存淘汰策略

过期策略：定期删除+惰性删除
定期：redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。
Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。
1. 从过期字典中随机 20 个 key；
2. 删除这 20 个 key 中已经过期的 key；
3. 如果过期的 key 比率超过 1/4，那就重复步骤 1；
惰性：用到的时候检查是否过期，要是过期则删除；
所以并不是过期了就会释放内存
###### 内存淘汰策略（六种）
要是没有设置过期时间，或者过期未清除的数据依旧占用内存，这时候Redis使用内存淘汰机制
1. no-eviction：不会淘汰（默认），内存到达设置的阈值之后不会进行数据淘汰，只能查询和删除，不能写入；
2. volatile-lru：针对设置了过期时间的数据，淘汰最近最少使用的key;
3. volatile-random：随机淘汰设置了过期时间的某个key；
4. volatile-ttl:淘汰剩余过期时间最少的key；
5. allkeys-lru：淘汰最近最少使用的key；
6. allkeys-random：随机淘汰键空间的某个key；
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典。
过期字典的键是一个指针，这个指针指向键空间中的某个键对象。
过期字典的值是一个long类型整数，这个整数保存了键所指的数据库键过期时间，一个毫秒精度的Unix时间戳。

### redis 哨兵模式


##### 京东金融redis实践
【https://www.infoq.cn/article/jingdong-redis-practice/】

##### redis 命令

GETSET 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。
SETNX  只有在 key 不存在时设置 key 的值。
 

