### synchronized 和 Lock 的区别，Lock有什么好处？
1.原始构成 
synchronized 是关键字，JVM层面的锁
Lock是一个具体的类，api层面的锁

2. 使用方法
synchronized 不需要手动释放锁
Lock 需要手动释放，有可能释放失败造成死锁

3. 等待是否中断
synchronized 不可中断，除非异常，不然都会正常运行完成
Lock 可中断，设置超时时间 或者 调用interrupt()方法

4. 加锁是否公平
synchronized 非公平
Lock 默认非公平，可以设置为公平

5. 是否支持Condition
synchronized 不支持
Lock 支持，可以精确唤醒


#### 公平锁、非公平锁
公平：多个线程按照申请锁的顺序加入队列排队，先到先得
非公平：队列中第一个和未加入队列的线程都可以竞争锁，失败后再加入到队列中

##### 那非公平锁和公平锁适合什么场合使用呢，他们的优缺点又是什么呢？
非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。

#### 可重入锁（递归锁）
线程可以进入任何一个已拥有锁 的锁同步代码块：
同一个线程在外层方法获取锁之后，在进入内层方法时会自动获取锁
synchronized、ReentrantLock就是可重入锁；
可重入锁最大特点就是避免死锁；

#### 自旋锁
没有获取到锁的线程不回立刻阻塞，而是用循环的方式去尝试获取锁，这样做的好处是减少线程上下文切换的消耗，缺点是比较消耗CPU；

#### synchronized底层原理
每个对象有一个监视器锁（monitor），Synchronized的语义底层是通过一个monitor的对象来完成，当monitor被占用时就会处于锁定状态。    
1、同步代码块 是通过 monitorenter 和 monitorexit 指令获取线程的执行权。
    
    线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：  
    1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。  
    2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。   
    3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。
    
    执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，
    那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。     
    
2、同步方法 是通过加 ACC_SYNCHRONIZED 标识实现线程的执行权的控制。
    
    synchronized修饰的方法 反编译后常量池中多了ACC_SYNCHRONIZED标示符。JVM会根据该标示符来实现方法的同步：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。
    
注：javap -c -s -v -l xxx.class 
Synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。
Synchronized总共有三种用法：（1）修饰普通方法（2）修饰静态方法（3）修饰代码块

#### 理解Java对象头与Monitor
JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。  
实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。  
填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。 
对象头：synchronized使用的锁对象是存储在Java对象头里的，普通对象头在32位系统上占用8bytes（一个字节），64位系统上占用16bytes(如果对象是数组则会分配24bytes，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成 。
