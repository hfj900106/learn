### synchronized 和 Lock 的区别，Lock有什么好处？
1.原始构成 
synchronized 是关键字，JVM层面的锁
Lock是一个具体的类，api层面的锁

2. 使用方法
synchronized 不需要手动释放锁
Lock 需要手动释放，有可能释放失败造成死锁

3. 等待是否中断
synchronized 不可中断，除非异常，不然都会正常运行完成
Lock 可中断，设置超时时间 或者 调用interrupt()方法

4. 加锁是否公平
synchronized 非公平
Lock 默认非公平，可以设置为公平

5. 是否支持Condition
synchronized 不支持
Lock 支持，可以精确唤醒


#### 公平锁、非公平锁
公平：多个线程按照申请锁的顺序加入队列排队，先到先得
非公平：队列中第一个和未加入队列的线程都可以竞争锁，失败后再加入到队列中

##### 那非公平锁和公平锁适合什么场合使用呢，他们的优缺点又是什么呢？
非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。

#### 可重入锁（递归锁）
线程可以进入任何一个已拥有锁 的锁同步代码块：
同一个线程在外层方法获取锁之后，在进入内层方法时会自动获取锁
synchronized、ReentrantLock就是可重入锁；
可重入锁最大特点就是避免死锁；

#### 自旋锁
没有获取到锁的线程不回立刻阻塞，而是用循环的方式去尝试获取锁，这样做的好处是减少线程上下文切换的消耗，缺点是比较消耗CPU；

