### springboot启动流程
Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成。



### 分布式
#### 分布式事务了解吗？你们是如何解决分布式事务问题的？
[http://www.wangzha.tech/archives/distributed-transaction]

分布式事务的实现主要有以下 5 种方案：
1. TCC 方案
2. 可靠消息最终一致性方案
3. XA 方案（不推荐）
4. 本地消息表（不推荐）
5. 最大努力通知方案

###### TCC（Try、Confirm、Cancel）
Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。
Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。
Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）。

这种方案说实话几乎很少人使用，自己手写回滚逻辑，或者是补偿逻辑，代价太大，业务代码很难维护。
一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。

###### 可靠消息最终一致性方案

直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。
大概的意思就是：
1. A系统先发送一个 prepared 消息到 mq，如果消息发送失败那么就直接取消操作；如果发送成功，那么接着执行本地事务，事务实行成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；

2. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；

3. mq 会自动定时轮询所有 prepared 消息并回调你的接口，确认这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？通常你的接口接口可以查下数据库看之前本地事务是否执行，如果回滚了，那么告诉mq回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。

4. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。

这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。


###### XA（二段提交）（不推荐）
适用于单模块对应多个数据库的应用，存在一个类似管理器的概念，管理器在提交事务之前会先确认是否每个数据库都已经准备好，都ok的情况下再正式提交事务；如果有一个不ok，回滚事务；
缺点：严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景；

###### 本地消息表（不推荐）
这个大概意思是这样的：
A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
接着 A 系统将这个消息发送到 MQ 中去；
B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；
B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；
如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；
这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。
这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。

###### 最大努力通知方案
这个方案的大致意思就是：

系统 A 本地事务执行完之后，发送个消息到 MQ；
这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；
要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。

###### 你们公司是如何处理分布式事务的？
如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。
