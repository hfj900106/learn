##### 事务ACID
原子性、一致性、隔离性、持久性

##### 事务传播分类
REQUIRED ：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。  
SUPPORTS ：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。  
MANDATORY ：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。  
REQUIRES_NEW ：创建一个新的事务，如果当前存在事务，则把当前事务挂起。  
NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。  
NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常。  
NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED。  

##### Spring 支持事务
Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编码式和声明式的两种方式。
编程式事务指的是通过编码方式实现事务；声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。
声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式。

##### @Transactional 注解管理事务的实现步骤
步骤1. 启用事务管理功能：
    方式1. 在 xml 配置文件中添加事务配置；
    方式2. @EnableTransactionManagement 注解（流行方式）；
步骤2. 将@Transactional 注解添加到合适的public方法上，并设置合适的属性信息（eg：rollbackFor）。    

注：@Transactional 注解也可以添加到类级别上。当把@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。

##### 坑点
1. Spring的默认的事务规则是遇到运行异常（RuntimeException及其子类）和程序错误（Error）才会进行事务回滚，所以遇到非（RuntimeException、Error）的时候要在@Transactional 注解里使用rollbackFor 属性明确指定异常
2. 在业务层捕捉异常后，发现事务不生效，业务层手工捕捉并处理了异常，你都把异常“吃”掉了，Spring自然不知道这里有错，更不会主动去回滚数据 
3. 应避免 Spring 的 AOP 的自调用问题，在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。

推荐：若非实际业务要求，则在业务层统一抛出异常，然后在控制层统一处理。  