## AbstractQueuedSynchronizer
AQS 是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。  

并发工具的设计套路：状态，队列，CAS

状态（state）：一般是一个state属性，它基本是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么。由于状态是全局共享的，一般会被设置成volatile类型，以保证其修改的可见性；state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁，这里之所以说大于0而不说等于1是因为可能存在可重入的情况。你可以把state变量当做是当前持有该锁的线程数量。

队列：AQS中，队列的实现是一个双向链表，队列通常是一个等待的集合，大多数以链表的形式实现。队列采用的是悲观锁的思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种类型的数据结构，扔到一个等待队列中，当一定条件满足后，再从等待队列中取出。

CAS：CAS操作是最轻量的并发处理，通常我们对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个死循环for(;;)。

### 独占锁
#### ReentrantLock 独占锁的获取
AQS中实现了锁的获取框架，锁的实际获取逻辑交由子类去实现，就锁的获取操作而言，子类必须重写 tryAcquire方法。

ReentrantLock有 公平锁 和 非公平锁 两种实现, 默认实现为非公平锁,
这里以ReentrantLock 中的FairSync 为例：

FairSync -> lock() -> acquire(1)

##### acquire() 中做什么事？这是一个模板方法设计模式，规定的acquire()要做的事情：
1. tryAcquire(arg)--子类 实现 获取锁的具体逻辑，要不实现直接用的话抛异常；
2. addWaiter(Node mode)--AQS实现--获取锁失败后，将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node；
3. acquireQueued(final Node node, int arg)--AQS实现--针对新加入队列的node不断尝试后续操作：如果preNode是head（队列里排第一），则尝试获取锁，如果preNode不是head，或者获取锁失败，则将当前线程挂起；
4. selfInterrupt()--AQS实现--中断当前线程

##### 独占锁的 tryAcquire() 都做什么？
1. 判断当前锁有没有被占用；
2. 如果锁没有被占用, 尝试以公平的方式获取锁；
3. 如果锁已经被占用, 检查是不是锁重入，是的话，持有锁线程数+1，不是重入，则获取锁失败；


##### 获取独占锁 总结：
1. AQS中用state属性表示锁，如果能成功将state属性通过CAS操作从0设置成1即获取了锁
2. 获取了锁的线程才能将exclusiveOwnerThread设置成自己
3. addWaiter负责将当前等待锁的线程包装成Node,并成功地添加到队列的末尾，这一点是由它调用的enq方法保证的，enq方法同时还负责在队列为空时初始化队列。
4. acquireQueued方法用于在Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起
5. shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL,从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。
6. parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。
7. 如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行；否则，线程会阻塞等待。

#### 独占锁的释放
 JAVA的内置锁在退出临界区之后是会自动释放锁的, 但是ReentrantLock这样的显式锁是需要自己显式的释放的, 所以在加锁之后一定不要忘记在finally块中进行显式的锁释放。
 
 以公平锁为例：
 FairSync -> unlock() ->release(1)

##### AQS 中 release(1)做了什么？
1. tryRelease(arg)，子类Sync重写具体逻辑（公平非公平都一样释放）；
2. 检查head和waitStatus，如果队列中还有等待线程，则唤醒(unparkSuccessor(Node h))，否则释放成功；


### 共享锁 ReentrantReadWriteLock
#### 写锁（WriteLock）获取
WriteLock -> lock() -> sync.acquire(1)

注：同步状态的 低16位 表示 写锁 的获取次数，高16位 表示 读锁 被获取的次数

##### acquire() 中做什么事？这是一个模板方法设计模式，规定的acquire()要做的事情：
1. tryAcquire(arg)--子类 实现 获取锁的具体逻辑，要不实现直接用的话抛异常；
2. addWaiter(Node mode)--AQS实现，和独占锁调用的是同一个；
3. acquireQueued(final Node node, int arg)--AQS实现，和独占锁调用的是同一个；
4. selfInterrupt()--AQS实现，和独占锁调用的是同一个；

##### WriteLock的 tryAcquire() 都做什么？
主要逻辑为：判断读锁是否已经被读线程获取 或者 写锁已经被其他写线程获取，是则写锁获取失败；否则，获取成功，写状态+1，设置写锁持有线程为当前线程。

#### 写锁（WriteLock）释放
重写AQS的tryRelease方法：
1. 当前同步状态-1（因为写状态是低16位，可以直接减）；
2. 减一之后的写状态是否为0，为0则释放写锁；
3. 不为0则更新同步状态；

#### 读锁（ReadLock）获取
1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前线程获取读锁失败返回-1；

#### 读锁（ReadLock）释放
注意修改状态的时候是高16位的，需要进行位移-1然后再位移更新回去

#### 锁降级
读写锁支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级