### lock的原理 就是AQS算法
AQS（AbstractQueuedSynchronizer）是JAVA中众多锁以及并发工具的基础，其底层采用乐观锁，大量使用了CAS操作， 并且在冲突时，采用自旋方式重试，以实现轻量级和高效地获取锁。  

并发工具的设计套路：状态，队列，CAS

状态（state）：一般是一个state属性，它基本是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么。由于状态是全局共享的，一般会被设置成volatile类型，以保证其修改的可见性；state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁，这里之所以说大于0而不说等于1是因为可能存在可重入的情况。你可以把state变量当做是当前持有该锁的线程数量。

队列：AQS中，队列的实现是一个双向链表，队列通常是一个等待的集合，大多数以链表的形式实现。队列采用的是悲观锁的思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种类型的数据结构，扔到一个等待队列中，当一定条件满足后，再从等待队列中取出。

CAS：CAS操作是最轻量的并发处理，通常我们对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个死循环for(;;)。

#### 独占锁的获取
AQS中实现了锁的获取框架，锁的实际获取逻辑交由子类去实现，就锁的获取操作而言，子类必须重写 tryAcquire方法。

ReentrantLock有 公平锁 和 非公平锁 两种实现, 默认实现为非公平锁,
这里以ReentrantLock 中的FairSync 为例：

FairSync -> lock() -> acquire(1)

##### acquire() 中做什么事？这是一个模板方法设计模式，规定的acquire()要做的事情：
1. tryAcquire(arg)--子类 实现 获取锁的具体逻辑，要不实现直接用的话抛异常；
2. addWaiter(Node mode)--AQS实现--获取锁失败后，将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node；
3. acquireQueued(final Node node, int arg)--AQS实现--针对新加入队列的node不断尝试后续操作：如果preNode是head（队列里排第一），则尝试获取锁，如果preNode不是head，或者获取锁失败，则将当前线程挂起；
4. selfInterrupt()--AQS实现--中断当前线程

##### tryAcquire() 都做什么？
1. 判断当前锁有没有被占用；
2. 如果锁没有被占用, 尝试以公平的方式获取锁；
3. 如果锁已经被占用, 检查是不是锁重入，是的话，持有锁线程数+1，不是重入，则获取锁失败；









