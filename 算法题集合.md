1. 假设我们有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据中？ 
我们希望这个功能不要占用太多的内存空间，最多不要超过100MB，你会怎么做呢？
答：
    我们的内存限制是100MB，每个数据大小是8字节，最简单的办法就是将数据存储在数组中，内存占用差不多是80MB，
    符合内存的限制。借助今天讲的内容，我们可以先对这1000万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。
    
    看起来这个问题并不难，很轻松就能解决。实际上，它暗藏了“玄机”。如果你对数据结构和算法有一定了解，
    知道散列表、二叉树这些支持快速查找的动态数据结构。你可能会觉得，用散列表和二叉树也可以解决这个问题。实际上是不行的。
    
    虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，不管是散列表还是二叉树，
    都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这1000万的数据，用100MB的内存肯定是存不下的。
    而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，
    所以刚好能在限定的内存大小下解决这个问题。

2. 为什么Redis要用跳表来实现有序集合，而不是红黑树？


3. Word文档中单词拼写检查功能是如何实现的？
    存储单位：bit、 B(byte)、KB、MB、GB、TB、、、
答：
    常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。
    当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。

4. 假设我们有10万条URL访问日志，如何按照访问次数给URL排序？
答：
    遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。
    如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。  


5. 有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？
答：    
    以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。
    
6. 散列表的插入、删除、查找操作的时间复杂度可以做到常量级的O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？    
答：
    1.散列表无序，要得到有序数据得先进行排序；二叉查找树中序遍历可以得到有序数据；
    2.散列表扩容消耗大；二叉查找树天然可扩容；
    3.散列表容易散列冲突，解决起来不如二叉查找树简单方便；
    4.散列表构造更为复杂；    

7. 如何通过编程，求出一棵给定二叉树的确切高度呢？
答：
    第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；  
    第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。    

8. 为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？
答：
其他平衡二叉查找树无法避免极端情况下时间复杂度的退化，而且维护平衡的成本高，
红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。
所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，
为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。    
