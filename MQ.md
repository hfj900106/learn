# MQ 连环问

#### 用消息中间件吗？为什么要用？有什么优缺点吗？
结合项目中的一些情景：
1. 解耦：用户在我们的平台上借款，需要和理财投资的资金进行匹配，那么当匹配成功后会推数据到账务系统，生成系列的账单，这时候要是直接调用那么系统间的耦合性比较强，这也体现了MQ的一个解耦的优点；
2. 异步：用户在平台上进行资料认证，这些数据会被同步到风控中心，那么直接调系统接口传送会增加响应时间，项目中把需要同步的信息先放到MQ中，等待风控来消费信息，异步处理的这个流程，缩短了用户的等待时间，这也体现了MQ的异步优点；
3. 削峰：

引入MQ 同时也会带来一些缺点：
1. 系统可用性降低：要是MQ挂了，那么可能导致整个系统崩溃；
2. 系统复杂性增高：要考虑MQ高可用、消息可靠传输、保证消息有序等等诸如此类的问题；
3. 一致性问题： A系统处理成功直接返回，人家以为你的请求直接成功了，如果B系统写入数据失败了，数据就不一致了；

对于MQ的选型：（待补充）

单机吞吐量： ActiveMQ 、 RabbitMQ 都是 万 级别；RocketMQ 、Kafka 10万 级别；
时效性：RabbitMQ 微秒 级别，其他都是 毫秒 级别；
可用性：ActiveMQ、RabbitMQ 可用性高，可基于主从高可用；RocketMQ 、Kafka 更高，基于分布式高可用；
消息可靠性： 
社区活跃度：综合来看，RabbitMQ 是首选；

ActiveMQ
ActiveMQ：万级吞吐量，ms时效性，有较低丢消息的可能行，社区不活跃，基于主从架构实现高可用性

RabbitMQ：万级吞吐量，微秒时效性，erlang开发，社区活跃，提供了完善的管理界面，基于主从架构实现高可用性

RocketMQ：10万级吞吐量，ms级，MQ功能较为完善，还是分布式的，扩展性好，阿里java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控

Kafka：10万级吞吐量，ms级，一般配合大数据类的系统来进行实时数据计算、日志采集等场景，非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，这个特性天然适合大数据实时计算以及日志收集



#### 如何保证消息高可用？



### 如何保证消息不会被重复消费，幂等性？
1. 使用唯一键 
2. 生产者发送数据的时候，加一个全局唯一id，消费者在消费的时候，用redis判断，这条数据有没有被消费过，消费过，就不在消费了

#### 如何保证消息的可靠性传输？如何处理消息丢失的问题？
数据丢失的情况一般分三种：发往MQ的路上丢失、MQ接收到消息还没来得及消费就丢失了、消费者拿到消息还没有来得及消费就丢失了；

生产者： 开始conform模式；
MQ： 开启持久化；
消费者： 关闭自动ack；

1. 针对发送方：开启 confirm 模式，每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
2. 针对mq服务器：这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。
　设置持久化两个步骤：

　　2.1 创建 queue 的时候将其设置为持久化，这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。
　　2.2 发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。
所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。

3. 针对消费者：这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。


#### 如何保证消息的顺序性？
需要保证顺序的数据的最小单位（比如123需要保证顺序，那么123放一起）放在一个queue里面，一个queue对应一个消费者，那么消费者拿到这个数据后悔有序执行；


#### 消息延时、过期失效如何处理？积压过多（比如几百万条）如何处理？队列满了装不下如何处理？
1. 过期失效的数据手动补偿，在流量比较低的时候将这些数据查询出来放入队列，重新处理；
2. 积压过多（可能是服务器故障导致），临时写个程序，连接到mq里面消费数据，收到消息之后直接将其丢弃，快速消费掉积压的消息，降低MQ的压力，然后低流量时去手动查询重导丢失的这部分数据，放入队列重新消费处理。


#### 设计一个消息队列，如何进行架构设计？
